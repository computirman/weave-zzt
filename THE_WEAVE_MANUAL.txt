################################################
               The Weave Manual
################################################

This document assumes you are familiar with creating ZZT games, and expects you to know something of how the different terrains, creatures, and items behave. The incomparable ZZT-OOP 101 (https://museumofzzt.com/article/view/747/zzt-oop-101/) by Dr. Dos is a fantastic resource explaining the behaviors of the base game, and this manual assumes you have read ZZT-OOP 101 and have a basic understanding of ZZT-OOP's standard commands.

== Version ==

The version of this manual is 0.6. It covers Weave versions 3.4 and later.

== Using this Manual ==

 * The introduction (Parts 1-3) is meant to be read fully and in order to familiarize you with some of the ways Weave is different to ZZT.
 * It is also recommended you take a look at part 6 ("Names") if you are interested in some of the expanded element and color names available to Weave.
 * Some entries will reference items in the appendices at the end of the document.
    - The appendices are not long and illuminate additional ways Weave can be used. It is recommended you look at them as well.
 * Parts 4 ("Directions"), 5 ("Commands"), and 7 ("Counters") are reference material, documenting Weave's capabilities more fully and entirely than anywhere else on the web. For these, refer back to them if you are interested in something specific you want Weave to do.

########################
        PART ONE:
     THE CORE FILES
########################

To understand how Weave modifies standard ZZT, it is important to understand that a Weave game, rather than always being a single file, can use (mostly) plaintext files to modify default behaviors. These modifications come in a few forms, listed below:

== The Game itself (GAME.ZZT) ==
A Weave .ZZT file is a vanilla .ZZT file in nearly all respects. Here are the differences:

 * Whereas a .ZZT file has a variable world limit of approximately 275kb, a Weave .ZZT file can be up to 16 megabytes. (For vintage systems using XMS and not EMS, this limit is restricted to 2 megabytes.)
 * Whereas a .ZZT file has a board limit of 101, Weave .ZZT files have a board limit of 254.
 * Whereas a .ZZT file has a per-board stat limit of 151, Weave .ZZT files can have up to 254 stats per board.
 * Whereas a .ZZT file will display some game elements with element numbers higher than 45 as text, this behavior is unpredictable and often crashes the game. Weave safely displays all elements higher than 45 as text, including all foregrounds and (non-blinking) backgrounds starting with element 128.

== The config file (GAME.CFG) ==
These configuration values can be used to alter the standard behavior of ZZT. All of these entries can be modified in-game; the .CFG file is just a convenient place to store your preferred defaults. Here are all the different kinds of values available:

 * The element table can be changed. These entries make a player look like a ruffian:

    player.char = 5
    player.fg = "Purple"
    player.bg = "Black"

 * The standard sounds and messages can be altered or silenced. These entries change the message and sound for forest:

    forest.msg.touch = "Your machete hacks through the brush."
    forest.snd.touch = "t84"

 * The standard sidebar elements can be reworded, mapped to different keys or removed entirely. These entries modify the sidebar Sound toggle:

    keys.sound.label.on = "Sound is ON "
    keys.sound.label.off = "Sound is OFF"

 * Some of ZZT's default behaviors can be changed. The following doubles the amount of damage the player takes from bullets and enemies:

    other.ouchdamage = 20

 * The game's UI theme can be recolored. The following changes the sidebar from a dark blue to a dark green:

    theme.bg.sidebar = "DkGreen"


== The INI file (GAME.INI) ==
These entries extend the functionality of ZZT. Weave will expect a .INI file, even an empty one, if Weave's full functionality is to be used in-game. These entries can only be set in the .INI file, not modified in real-time. Here are some additional things that can be added:

 * Additional keybinds can be added. These entries add a keybind for the 'I' key that sends the :INVENTORY label to all objects named @INPUT.

    input.1.keybind = "I"
    input.1.label = "Inventory"
    input.1.sidebar.row = "19"

 * New world flags can be added. These entries allow objects to track these flags with #set, #clear, and #if, but without using one of your flag slots:

    world.flag = "CROWBAR"

 * New counters can be added. These entries allow objects to modify these counters with #give and #take:

    world.counter = "LOAVES"
    world.counter = "FISHES"

 * New sidebar entries can be added that display these new counters. The following entry would display the current number of "FISHES" as defined above with the symbol for sharks (^) displayed alongside:

    sidebar.13.counter = [38," Fishes:"]

The ".13" in the above entry refers to line 13, where the counter is displayed. (This places it directly below the entry for "Keys".) The 38 in the above entry refers to the element # for sharks. For a complete listing of element #s, see part 7 of this document, under the section "Internal Counters: Elements".

== OTHER FILES ==

 * OBJECT FILES (*.OBJ)
    - These are textfiles containing ZZT-OOP. You can load them into objects with the #load command, replacing the existing code, or run them once with the #run command, returning the object to its original code when complete.

 * CHARACTER SETS (GAME.CHR)
    - These are pure binary character sets that the game will load on startup.
    - Only 8x14 character sets are supported.
    - Legacy tools, such as Font Mania (REXXCOM Systems, 1992) or MegaZeux (Unknown origin) can be used to create these files. More information on creating them, refer to the manuals for those applications.

 * PALETTE FILES (GAME.PAL)
    - These are binary palette files that redefine ZZT's standard 16 colors.
    - These colors can also be modified in-game using the #PALETTE command.
    - The acceptible range of values match the input restrictions for #PALETTE; see the entry for that command for details.    

 * HELP FILES (GAME.HLP)
    - A custom help file for your game, that is displayed when the player hits 'H' while playing the game.
    - Both Weave and Vanilla ZZT can load and display .HLP files, using the file hyperlink format "!-file;Link Text". 

 * The Weave config file (WEAVE.CFG)
    - This provides Weave with the default speed, accessibility settings, release status, and filename to load on startup for the game.
    - For specifics on the entries that go into a WEAVE.CFG file, see Appendix D, "WEAVE.CFG".


#######################
       PART TWO:
    LINE FORMATTING
#######################

In addition to the line formatting of Vanilla ZZT, two additional line beginnings are also available:

== Pre-zapped links ==

    @mylink;Link Text

These are similar to the 'label pre-zapped labels. To restore one, you can use:

    #RESTORE !mylink

And it will become a selectable link again.

== Special Text ==

The $ symbol is used in text boxes to display white, centered text. In exactly the same way, character #255 (which looks like an empty space) is used to display Special Text, which is left-justified, uniquely colored text. You can place this character in LOOMzzt with Ctrl+A.

You can choose the color of special text in the .CFG file with:

    theme.fg.special = "Red"

Or in-game with:

    #SET theme.fg.special RED

To note: Special text is left-indented by a single character, so you will need to add a space or two after Character #255 to ensure your text displays correctly in the text window.

#####################
     PART THREE:
       LABELS
#####################

Mostly, :label text works the same as in vanilla ZZT. The following exceptions below have been divided into "built-in" and "custom" labels:

== Built-in Labels ==

In addition to the built-in labels of Vanilla ZZT, the :ENTER label has been added, which is sent to all objects upon the player entering the board.

The following are special built-in labels that only apply to objects named @INPUT:

   :up
   :down
   :left
   :right

Triggered on player movement. Players that are #LOCKed do not move and so do not trigger these.

   :shiftup
   :shiftdown
   :shiftleft
   :shiftright

Triggered on player attempting to shoot, either with SHIFT or SPACE. Players that are #LOCKed cannot shoot and so do not trigger these.

   :keyboarda
   :keyboardb
   (...)
   :keyboardz

   :keyboard1
   :keyboard2
   (...)
   :keyboard9

Triggered when the corresponding key on the keyboard is pressed. Still triggers when the player is #LOCKed as it registers on keypress, not player movement.  Take special note that ":keyboardq" will never be triggered as the player Quit prompt will come up instead.

   :space

Triggered when SPACE is pressed on the keyboard. Still triggers when the player is #LOCKed as it registers on keypress, not player movement.

== Custom Labels ==

A couple things to note about custom labels: 
 * Using numbers in labels works just fine in Weave, unlike vanilla ZZT. There is no strange behavior.
 * Items in the .INI file beginning with "input.#" send all objects named @INPUT to the label defined in "input.#.label".

####################
     PART FOUR:
      MOVEMENT
####################

To start, a few notes:

 * Scrolls can move in Weave if desired; no crashing, everything works fine there.

 * #GO, #WALK, #TRY, #IDLE, /, and ? behave the same as they do in vanilla ZZT. 

 * In addition to the above, objects can move one another, the player, or other parts of the board using #SHOVE, among other new commands that take directions as input. For more details on those, please see the entry for #SHOVE in the command list below.

 * Out-of-bounds checking in Weave is universal; objects cannot interact with out-of-bounds areas in any way.

== Directional Modifiers ==

Vanilla ZZT has a number of modifiers that can be applied to a direction (cw, ccw, opp, rndp). In addition to these, Weave adds the foollowing:

 * UNDER <dir>

Targets the tile underneath the stat, if there is a stat currently on the tile. Otherwise, targets the tile.

 * FIND <dir>

Uses very simple pathfinding to try and reach <dir>.

 * TO <dir> <dir>

Adds the next two directions together. For example, "TO S W" targets the tile southwest of the object.

== Directions ==

Along with SEEK, FLOW, and other vanilla ZZT directions, Weave provides the following:

 * AT <x> <y>

Targets a specific location on the board. Valid <X> values are 1-60, valid <Y> values are 1-25.

 * TOWARD <x> <y>

Like SEEK, but toward a specific location on the board rather than the player.

 * BY <x> <y>

Position relative to the object. For example, "BY 10 -4" would be ten tiles to the east and 4 to the north.

 * PLAYER

The player's current position on the board. "TO PLAYER W" targets the tile west of the player, "#SHOOT PLAYER" directly damages the player, and so forth.

 * PFIND [color] [bgcolor] <type>

The position of the first tile that matches the color and type specified. This is the same tile targeted in Vanilla ZZT with an "#IF ANY" check.

####################
     PART FIVE:
      COMMANDS
####################

Commands in Weave look and behave like commands in vanilla ZZT. Some commands are new, and some are existing commands that can take additional parameters.  They are listed below side-by-side, in alphabetical order.

== #AND <code> ==

Executes if the previous #IF command evaluated to True.

    #IF NOT BLOCKED N SHOOT N
    #AND BECOME RED FAKE

In this example, the object will check if it's blocked to the north, #shoot north if it isn't, and turn into a red fake on the following tick. If the object is blocked to the north, it will do nothing.

== #BGPLAY <sound> ==

Like #PLAY, but acts like a sound effect in-game, in that multiple #BGPLAY commands are not queued (instead new ones override the old) and high-priority sounds like the energizer song or #PLAY commands take precedence.

== #BOARD <destination> [x] [y] ==

Relocates the player to a new board as though they stepped onto a passage or board edge. Optionally can choose a specific X and Y location for the player. Board destinations can take a few different forms, listed below:

 * A board :label

If a board name includes a label, such as ":somelabel;My Board", then it can be referenced in #BOARD and other commands with a destination. In this example:

    #board somelabel 10 5

Will transport the player to a board labeled :somelabel and attempt to put the player at location (10, 5) on that board. Note that unlike passages, the #BOARD command does not pause play and emits no sound effect.

 * A board edge
    - EdgeN, EdgeS, EdgeE, or EdgeW

If a board has a valid board connection, this can be referenced in #BOARD and other commands with a destination. "#BOARD EdgeW" will attempt to send the player directly to the board linked to the west. Note, it is wise to validate that such a link exists, using "#IF EdgeW BOARD EdgeW" or similar; otherwise the player may end up on the title screen.

 * A stored BoardID
    - A BoardID stored in a custom counter, such as 'ReturnTo'

If a custom counter has been defined in the game's INI file, for example:

    world.counter = "ReturnTo"

This can store a BoardId value for later use. Say you wanted to visit a board, like a map or menu, and then return to wherever you came from. You could accomplish this by running the following commands:

    #SET ReturnTo BoardId
    #BOARD MapScreen

This would save the current BoardId in the 'ReturnTo' counter and teleport the player to a board named ":MapScreen;Overworld Map" or similar. Once you were done, you could send the player back with:

    #BOARD ReturnTo

This would return the player to their previous board.

== #CLEAR <counter> ==

In addition to unsetting flags, #CLEAR can set the value of a given counter to 0. For example:

    #CLEAR AMMO

Will take away all the player's ammo.

== #COLOR <dir> <color> [bgcolor] ==

Recolors a tile to the given color. For example, "#COLOR I Red DkRed" will make an object recolor itself red on a dark red background.

Note: Custom counters can store color data. For more information on this, see Appendix C: "Color Substitution".

== #RETRY ==

Returns to the beginning of the line and starts again.

If the beginning of the line is a /dir or ?dir movement, it will try to move immediately.

Otherwise it will wait and try again next tick.

== #DIE ITEM ==

Similar to items like ammo, gems and torches, an object that dies with #DIE ITEM will place the player on its current position as it dies.

== #DUPLICATE <inputdir> <outputdir> ==

Duplicates whatever it finds at <inputdir> and places it at <outputdir>. This behavior is identical to how a duplicator operates in Vanilla ZZT, except the source and destination directions can be chosen separately.

== #EDGE <dir> <destination> ==

Changes the board edge in a given <dir> to a given destination board. Board destinations can take a few forms; for details, see the entry for #BOARD or the appendix titled "Destinations" at the end of this document. For example:

    #EDGE N someboard

Will link the north board edge to a board labeled ":someboard;New Board" or similar. To remove a board link entirely, use:

    #EDGE N FALSE

This will remove the board link.

== #ELSE <code> ==

Like #AND, #ELSE depends on the previous #IF statement, but unlike #AND, #ELSE only executes when the previous #IF statement evaluates False:

    #IF NOT BLOCKED N SHOOT N
    #ELSE SHOOT S

In the above example, the object will shoot to the north unless blocked to the north, in which case, it will shoot to the south. There are two important things to note here: If you want multiple things to happen when the prior #IF statement evaluates False, use multiple #ELSE commands, like so:

    #IF NOT BLOCKED N SHOOT N
    #ELSE SHOOT S
    #ELSE BECOME PURPLE SLIME

In addition to shooting to the south, this object will now ALSO turn into a purple slime if it is blocked to the north. You can check multiple conditions by chaining these statements:

    #IF NOT BLOCKED N SHOOT N
    #ELSE IF NOT BLOCKED S SHOOT S
    #ELSE DIE

In this scenario, the object will shoot north if it is not blocked to the north, shoot south if it is blocked to the north but not the south, and die if it is blocked to both the north and south.

!! WARNING: THE FOLLOWING CODE IS VALID, BUT MIGHT NOT DO WHAT YOU THINK !!

    #IF NOT BLOCKED N SHOOT N
    #ELSE SHOOT S
    #AND BECOME PURPLE SLIME

!! Remember, the #AND command will execute if the prior #IF command evaluated True, so in the above scenario, the object will turn into a purple slime if it is NOT blocked to the north. If it is blocked to the south, it will shoot south, but not turn into a slime. !!

Keeping in mind the above, you can use #IF, #AND and #ELSE to evaluate many different kinds of conditions:

    @ForeverSlime
    :loop
    #IF NOT ANY RED BREAKABLE
    #AND IF NOT ANY RED SLIME
    #AND CHANGE RED SOLID EMPTY
    #AND PUT S RED SLIME
    #ELSE CHANGE RED BREAKABLE SOLID
    #ELSE /i#loop
    Time for a new Slime!
    #loop

Test the above code for yourself to see how it works.

== #FGPLAY <notes> ==

Like #PLAY, but checks that the queue is empty, or will soon be empty, before adding <notes> to the sound queue. If the queue is too full, it will try again on its next tick, similar to how /movement works.  Useful for playing long songs without having to calculate how many /i commands are needed to keep the buffer from overrunning.

== #GIVE <counter> ==

Shorthand for #GIVE <counter> 1. For example:

    #GIVE AMMO

Will give the player exactly 1 ammo.

== #IF <condition> <code> ==

In addition to ANY, BLOCKED, and similar from Vanilla ZZT, Weave adds the following conditionals for testing:

 * #IF ALIGNED
    - If you like, you can spell aligned correctly in your code, without the extra L.

 * #IF AT <x> <y>
    - Evaluates true if the object is currently at the given (x, y) location on the board.

 * #IF CANPUT <dir>
    - Evaluates true if the object can #put a stat nondestructively in a given direction, because either it is not blocked, or there's water in that direction.
    - Elements where CANPUT is true and WALKABLE is false behave like water, with bullets being able to pass over but other stats being unable.

 * #IF CANSHOOT <dir>
    - Evaluates true if the object can shoot in a given direction, either because there is a breakable in that direction, is it unblocked, or it is over water.

 * #IF COLOR <dir> <color> [bgcolor]
    - Evaluates true if the color of the tile in the given direction matches the given color.
    - Optionally, a background color can also be specified.
    - Custom counters can store color data, which can be used in these checks. For more information on this, see Appendix C: "Color Substitution".

 * #IF DETECT <dir> <color> [bgcolor] <type>
    - Like #IF COLOR, but looks for a specific element type in the given direction.
    - Custom counters can store color data, which can be used in these checks. For more information on this, see Appendix C: "Color Substitution".

 * #IF PUSHABLE <dir>
    - Evaluates true if the element in the given direction is one that can be pushed.
    - Note: this does not evaluate False if the element can't CURRENTLY be pushed because of something blocking on the other side.

 * #IF SEEDARK <dir>
    - Evaluates true if the element in the given direction can be seen on a dark board, such as passages and torches.

 * #IF RND
    - Evaluates true 50% of the time.

 * IF RUN <function> 
 * IF RUNWITH <counter> <function> 
    - Evaluates true if a given function terminates with #END TRUE
    - Also evaluates true if the function terminates with #END <#> where <#> is any positive number.
    - For more information, visit the appendix called "Functions" at the end of this document.

 * #IF WITHIN <range>
    - Evaluates true if the player is within a given range.
    - This range is visually roughly circular, similar to the radius of a bomb.

 * #IF <counter>
    - Evaluates true if <counter> is a positive number.
    - "#IF gems send HasGems" will go to the label :HasGems so long as the player has at least 1 gem.

 * #IF <counter> ABOVE <#>
 * #IF <counter> BELOW <#>
 * #IF <counter> IS <#>

    - Evaluates true if <counter> is either above, below, or equal to a given number, respectively.

 * #IF <condition> OR <condition>
    - Evaluates true if either condition evaluates to true.

 * #IF <condition> OR <condition> OR <condition>
    - OR can be stacked multiple times. If any of them are true, evaluates to true.

== #LOADGAME [file] ==

Loads [file].SAV and immediately begins playing it.

Unlike restoring a save from the title screen, the Player does not pause, making the file loading seamless.

If no [file] is specified, will open the game restore dialog.

If a .ZZT file is specified, will open that ZZT file and immediately begin playing it.

See also #SAVEGAME.

== #LOCK <dir> ==

If you append a direction to #LOCK, it will attempt to set the "locked" status of any stat it finds in that direction.

Importantly:

    #LOCK PLAYER

Will suppress all player movement and standard keyboard input such as [P]ause. Nonstandard keyboard input (Defined in the .INI) and mouse input still work.

See also #UNLOCK.

== #OUT <originx> <originy> <offsetx> <offsety> ==

Captures the tile at <originx> + <offsetx>, <originy> + <offsety>, and adds a "#PUT BY <offsetx> <offsety>" command to the output buffer for that tile.

!! Warning: The output buffer is used when loading ANY file - if you run #OUT/#XOUT in a function from an external file, save and restore your game, or attempt to #Load another object with code while building the output buffer - the operation WILL fail. !!

See also #XOUT.

== #PALETTE <color> <r> <g> <b> ==

Changes the <r>,<g> and <b> values of color <color>. Accepted values for <r>, <g> and <b> are 0-63.

Note: Custom counters can store color data, making it possible to modify the entire palette using a simple loop. For more information on this, see Appendix C: "Color Substitution".

== #PLAY Ãœ ==

Plays a scary noise.

== #PLAYER <fg> <bg> <char> ==

Changes the player character's appearance. For example, you can make the player into a red-on-black char 3 (Heart) with the following command:

    #PLAYER RED BLACK 3

The player can be reset to default appearance at any time with "#PLAYER 0 0 0".

You can also "transform" the player to look like another element with "#CHANGE PLAYER <type>."

Note: Custom counters can store color data. For more information on this, see Appendix C: "Color Substitution".

== #PSET <dir> <attribute> <value> ==

Changes the attributes of a stat found at <dir>. Below are the list of attributes that can be changed:

 * ARRAY <#>
    - Sets an object's ARRAY value.
 * CHAR <#>
    - Sets an object's character.
 * CYCLE <#>
    - Sets the cycle of any stat.
 * DESTINATION <boardlabel>
    - Sets the destination of a passage to a board with boardlabel.
    - For more info, see the 'Destinations' Appendix at the bottom of this document.
 * DURATION <#>
    - "#PSET MSGTXT DURATION" sets the duration, in ticks, of the currently displayed message.
    - On a Bomb, DURATION is the duration, in bomb ticks, of each displayed number before it decreases
    - On a Blinkwall, DURATION is the time elapsed since the beginning of the blink cycle.
 * INTELLIGENCE <#>
    - Sets the intelligence of the following enemies: Bear, Ruffian, Shark, Spinning Gun, Lion, Tiger, and Head.
    - Can also abbreviate to INTEL.
 * P1/P2/P3 <#>
    - Sets the P1/P2/P3 value of any stat.
 * ORIGIN <dir>
    - "#PSET MSGTEXT ORIGIN <dir>" modifies the origin of "ticker" message text.
    - On a Duplicator, sets the direction of the origin tile.
 * RATE <#>
    - On Spinning Gun and Tiger, sets the firing rate
    - On Ruffian, sets the resting rate
    - On Head, sets the rate of deviation
    - On Duplicator, sets the duplication rate
    - On Blinkwall, sets the overall blink rate
 * SPEED <#>
    - On Slime, sets the slime speed.
 * STEP <dir>
    - Sets the step values of any stat.
 * OBJ1..OBJ6 <#>
    - Sets an object's local variables.

== #RESTORE <![object:]link> [#], #RESTORE <label> <#> ==

The #RESTORE command now has two additional parameters it can accept:

 * RESTORE !link
    - Restores hyperlinks that were #ZAP'd.
    - Can also restore other objects' hyperlinks, e.g. "#RESTORE !otherobject:link"
    - Can restore pre-#zapped labels (See the entry for '@' in Part Two earlier in this document)
 * RESTORE label <#>
    - Restores a specific number of #ZAP'd labels.
    - If a negative number is chosen (as in "#RESTORE label -3") then #ZAP'd labels are restored starting from the end of the object code and working backward
    - This also works for restoring !links.

See also #ZAP.

== #RUN, #IF RUN, #RUNWITH ==

A complete description of RUN and RUNWITH functions can be found by visiting appendix B, "Functions", located at the end of this document.

== #SEND /<dir> ==

Without knowing the @Name of an object, you can still send it messages by adding a parameter to the #SEND command:

    #SEND /n fromsouth

This example will send the :fromsouth label to any object it finds to the north.

== #SET <counter> <#> ==

The #SET command can now be used to set counters to a specific number. For example:

    #SET ammo 40

Would leave the player with exactly 40 ammo; no more, no less. 

See Part Seven ("Counters") below for more information about the kinds of counters you can set in-game.

== #SHOVE <dir1> <dir2> ==

This will shove whatever it finds at <dir1> in the direction of <dir2>. Depending on what's getting pushed where, there are 4 different outcomes for the destination tile:

 * If the DESTINATION tile IS PUSHABLE in the direction of <dir2>, it will be pushed out of the way by the source tile.

    Otherwise...

 * If the DESTINATION tile HAS A STAT, #shove will do nothing.

    Otherwise...

 * If the SOURCE tile HAS A STAT, it will be #shove'd on top of the destination, with the destination tile now UNDER the stat.

    Otherwise...

 * The destination tile will be DESTROYED by the source tile.

== #SOUT <counter> ==

Captures the value and name of <counter>, and adds a "#SET <counter> <value>" command to the output buffer.

!! Warning: The output buffer is used when loading ANY file - if you run #SOUT/#XOUT in a function from an external file, save and restore your game, or attempt to #Load another object with code while building the output buffer - the operation WILL fail. !!

See also #XOUT.
 
== #STARTGAME [board] ==

Executed from the title screen. Starts the game. Optionally, a :board label can be provided, which starts the game on that board instead of the usual start board. During gameplay, does nothing.

== #STEP <dir1> <dir2> ==

An alias for "#PSET <dir1> STEP <dir2>". For more information, see the above entry on #PSET.

== #TAKE <counter> <code> ==

An alias for #TAKE <counter> 1 <code>. For example:

    #TAKE GEMS NoGems

Will take a single gem, or send the player to :NoGems if they don't have any.

== #WRITE <dir> <fg> <bg> <TEXT> ==

Creates custom text at <dir> of the given foreground and background color. The <TEXT> is the content to be drawn to screen. For example, this will write "Hello World" to the top left of the screen in gray text:

    #WRITE AT 1 1 GRAY BLACK Hello World

Note: Custom counters can store color data. For more information on this, see Appendix C: "Color Substitution".

== #XOUT <filename> ==

See also #OUT and #SOUT.

 * Takes the contents of the output buffer (built one line at a time with #OUT and #SOUT commands) and saves it to a file <filename>.OBJ.
    - In this way, the contents of the buffer can be recreated using a #RUN <filename> command.
 * This allows you to "copy" sections of a board during the game which you can "paste" into later boards in the game.
    - For example, it can store the name of the protagonist, which can then be inserted into cutscenes and other on-board elements.
 * This also allows you to "save" the current value of counters for later runs.
    - This can be used to keep track of "unlockable" progress such as achievements.

== #ZAP <!link> <#>

The #ZAP command now has two additional functions it can perform:

 * ZAP !link
    - ZAPs hyperlinks, making them no longer visible or selectable in dialog.
    - Can also ZAP other objects' hyperlinks, e.g. "#ZAP !otherobject:link"
 * ZAP label <#>
    - ZAPs the given number of labels, as though multiple identical #ZAP commands were issued in a row.
    - If a negative number is chosen (as in "#ZAP label -3") then labels are #ZAP'd starting from the end of the object code and working backward.
    - This also works for #ZAP-ing !links.



####################
     PART SIX:
       NAMES
####################

Weave provides names for all elements on the board and all 16 colors. Here are the ones vanilla ZZT forgot to cover:

== New Elements ==

 * EDGE
    - A board edge.
 * BlinkNS
    - A north/south blinkwall.
 * BlinkEW
    - An East/West blinkwall.
 * Darkness
    - The tile displayed in unlit areas when the board is dark.

== Named Text Elements == 

All seven original kinds of text now have names:
 * Bluetext
    - Colored White-on-Dark Blue.
 * Greentext
    - Colored White-on-Dark Green.
 * Cyantext
    - Colored White-on-Dark Cyan.
 * Redtext
    - Colored White-on-Dark Red.
 * Purpletext
    - Colored White-on-Dark Purple.
 * Yellowtext
    - Colored White-on-Brown.
 * Whitetext
    - Colored White-on-Black.

== Custom Text Elements ==

Custom text (placeable in-game using #WRITE, or added via the LOOMzzt editor) can be referenced in the following way:

[char] TEXT <fg> <bg>

So to turn all red-on-dark-red custom text into blue-on-dark-blue custom text, you would write:

    #CHANGE TEXT RED DKRED TEXT BLUE DKBLUE

And to remove all capital As from the result, you would run:

    #CHANGE 65 TEXT BLUE DKBLUE EMPTY

All custom text inherits its properties from element 46, "CUSTOMTEXT". So if you wanted all custom text in the game to be walkable, you would run:

    #SET customtext.walkable true

For more information, see the Customtext section in Part Seven, "Elements".

== Colors ==

In addition to the seven named colors in ZZT, the following colors now have names:

 * Black
 * DkBlue
 * DkGreen
 * DkCyan
 * DkRed
 * DkPurple
 * Brown
 * Gray
 * DkGray

Any or all of these can be used in any command, such as #PUT, #IF ANY, #IF DETECT or #CHANGE, that takes a color and type as input. Also, custom counters can store color data. For more information on this, see Appendix C: "Color Substitution".


###################
    PART SEVEN:
     COUNTERS
###################

Counters fall into three categories: Custom, Internal, and Local. Internal can further be broken down into Elements, Built-ins, and Read Only, Theme, and Other. The commands used to change them are the same, but each one has a different benefit, so you will likely use one or two of these types, whichever suits your needs. We'll go over each of these in the sections below:

== Substitution ==

Wherever you might use a number in a command, /direction or conditional, you can substitute the name of a counter instead and the current value of that counter will be used. For example:

    #CHAR ammo

This will set the objects character to equal the current amount of ammo the player has. If the player has no ammo, then, similar to if #CHAR 0 had been executed, there will be no effect. If the player has more than 255 ammo, say 600, then it will be similar to #CHAR 600 having been run, and also have no effect. For another example:

    #IF NOT AT somex somey ?toward somex somey

This conditional relies on two custom counters, "somex" and "somey", to hold values matching a coordinate on the screen. 

For more information on defining and using custom counters, see the "Custom Counters" section below:

== Custom Counters ==

As mentioned in Part One above, additional counters can be added to the game by defining them in the game's .INI file:

    world.counter = "apples"
    world.counter = "pears"
    world.counter = "foo"
    world.counter = "bar"

These can be modified with #GIVE, #TAKE, #SET, and #CLEAR like so:

    #GIVE apples 10
    #TAKE pears 5 TooPear
    #SET foo 13
    #CLEAR bar

They can be compared with other numbers, and each other:

    #IF apples ABOVE bar BECOME FAKE
    #IF pears BELOW bar GIVE pears 3
    #If foo IS 13 ENDGAME

If a numeric value is used anywhere in game, these custom counters can be used there as well:

    #SET apples pears
    #CHAR foo
    #SHOVE i AT 15 bar
    #PUT E pears GREENTEXT

Additionally, they can store values such as color information and destination information:

    #SET apples PGET N COLOR
    #SET pears PGET N CHAR
    #SET foo PGET PFIND WHITE PASSAGE DESTINATION

And use those values later:

    #COLOR S apples
    #CHAR pears
    #BOARD foo

Up to 99 of these counters can be defined in the .INI file.

Note: Custom counters can store color data. For more information on using counters to represent colors, see Appendix C: "Color Substitution". For information on storing existing color data as counters, see the entry for #PGET.


== Local Counters ==

The following counters are set per-board:
 * Local1
 * Local2
...
 * Local7
They can be #SET, #CLEAR'd, #GIVEn to and #TAKEn from, and every board has their own set to use.

The following counters are set per-object:
 * Obj1
 * Obj2
...
 * Obj6
 * Array

Every object, even objects whose code is shared with #BIND, have their own individual counters which can be read, compared and modified. This means objects can share the same #BIND but behave differently depending on what they have stored in their local counters.


== Internal Counters: Built-ins ==

There are a number of counters that correspond to parts of the game state you may already be familiar with. In addition to those already accessible in vanilla ZZT (ammo, gems, score, etc.) the following builtin counters can be read and also modified as explained below:

 * BLUEKEY...WHITEKEY
    - Giving and taking keys is now as simple as #SET REDKEY, #CLEAR GREENKEY, etc.
    - Verifying whether the player has a key is as simple as "#IF REDKEY <code>", "#IF NOT GREENKEY <code>".
    - Vanilla ZZT technically left room in the data to store hundreds of keys. You can #GIVE, #TAKE, and compare these key values the same as any counter. Up to 99 keys of each color can be held at a time.
 * TICKSPEED
    - Similar to setting it in the main menu, you can #SET TICKSPEED <1-9> in-game, with 1 being fastest and 9 being slowest.
 * ISDARK
    - You can #SET ISDARK TRUE to darken a room. You can #SET ISDARK FALSE to lighten a dark room.
 * MAXBULLETS
    - You can #SET MAXBULLETS from 0 to 100; this changes the maximum number of bullets that can spawn at the same time on the current board.
 * ENERGIZED
    - This sets the number of ticks of Energizer energy the player has left.
 * WICK
    - This sets the number of torch cycles left in the currently lit torch.
    - You can set this value to -1 for a torch that never extinguishes.
 * TIMELIMIT
    - This sets the time limit on the current board.
 * HIDELINE3..HIDELINE24
    - These can be #SET and #CLEARed to hide and reveal elements of the sidebar (Useful when gradually introducing a player to more and more game elements, as in a tutorial)

There are also built-in counters that define the text displayed on the sidebar. These are:

 * counter.health
    - Changes the sidebar's display of the player's health.
    - Default is " Health:"
    - Use #CLEAR counter.health to remove this element from the sidebar.
    - Even if the UI element is removed, Player health is still being tracked and if it reaches 0, the game will still end.

 * counter.ammo
    - Changes the sidebar's display of the player's ammo.
    - Default is "   Ammo:"
    - Use #CLEAR counter.ammo to remove this element from the sidebar.
    - Even if the UI element is removed, the Ammo counter is still around and unless the MAXBULLETS counter is set to 0 on that board, the player will still be able to shoot if they have ammo.

 * counter.torches
    - Changes the sidebar's display of the player's torches.
    - Default is "Torches:"
    - Use #CLEAR counter.torches to remove this element from the sidebar.
    - Even if the UI element is removed, torches can still be lit in dark rooms.

 * counter.gems
    - Changes the sidebar's display of the player's gem count.
    - Default is "   Gems:"
    - Use #CLEAR counter.gems to remove this element from the sidebar.

 * counter.score
    - Changes the sidebar's display of the player's score count.
    - Default is "  Score:"
    - Use #CLEAR counter.score to remove this element from the sidebar.
    - Even if the UI element is removed, the score is still being tracked and unless other.highscores is set to FALSE, the player will still be prompted to enter a high score when the game ends.

 * counter.keys
    - Changes the sidebar's display of the keys in the player's inventory.
    - Default is "   Keys:"
    - Use #CLEAR counter.keys to remove this element from the sidebar.

 * counter.time   
    - Changes the way the TIME counter is displayed.
    - Default is "   Time:"
    - Appears optionally on timed boards.
    - Use #CLEAR counter.time to remove this element from the sidebar.

 * keys.torch.bind
    - The keybind that activates a torch.
    - Should be no more than 1 character long.
    - Default is "T"
    - Set to "" to disable using torches.

 * keys.torch.label
    - The displayed label on the sidebar for torches.
    - Default is "Torch"

 * keys.sound.bind
    - The keybind that toggles sound on and off.
    - Should be no more than 1 character long.
    - Default is "B"
    - Set to "" to disable toggling of sound.

 * keys.sound.label.on
    - The message displayed in the sidebar when sound is enabled.
    - Default is "Be quiet"

 * keys.sound.label.off
    - The message displayed in the sidebat when sound is disabled.
    - Default is "Be noisy"

 * keys.help.bind
    - If enabled, the keybind that will load <YOURZZT>.HLP 
    - Should be no more than 1 character long.
    - Default is "H"

 * keys.help.label
    - The displayed label on the sidebar for the Help hotkey.
    - Default is "Help"

 * keys.save.bind
    - The keybind for saving the game.
    - #CLEAR or set to "" to disable saving.
    - Should be no more than 1 character long.
    - Default is "S"

 * keys.save.label
    - The displayed label on the sidebar for game saving.
    - Default is "Save Game"

 * keys.pause.bind
    - The keybind for pausing the game.
    - #CLEAR or set to "" to disable pausing.
    - If this keybind is removed, other instances of pausing such as restoring saved games and starting the game with 'P' are also removed.
    - Should be no more than 1 character long.
    - Default is "P"

 * keys.pause.label
    - The displayed label on the sidebar for pausing the game.
    - Default is "Pause"

 * sidebar.pause.msg
    - The displayed message on the sidebar when the game is paused.
    - Default is "Pausing..."

 * sidebar.titleprompt
    - The displayed message on the title screen prompting player input.
    - Default is "Pick a command:"

 * sidebar.move.msg
    - The displayed label on the sidebar for player movement.
    - Default is " Move"
    - Unless #CLEARed or set to "", this will be accompanied by arrows pointing up, down, left, and right.

 * sidebar.shoot.msg
    - The displayed label on the sidebar for player shooting.
    - Default is " Shoot"
    - Shooting still works even if this value is #CLEARed or set to "".

 * sidebar.shift.msg
    - Alongside Sidebar.shoot.msg, the indicated key to denote shooting.
    - Default is " Shift "
    - Unless #CLEARed or set to "", this will be accompanied by arrows pointing up, down, left, and right.
    - Even if the UI element is removed, shooting is still enabled.

 * keys.cheat.bind
    - The keybind for the sidebar cheat menu.
    - #CLEAR or set to "" to disable cheats.
    - Should be no more than 1 character long.
    - Default is "?"

== Internal Counters: Read Only ==

In addition to game data that can be changed in the form of counters, some counters can be used in substitution (as replacement for numeric values in things like #CHAR, /AT etc.) but can't be #SET, #CLEARed, #GIVEn, or #TAKEn themselves. A list of these is below:

 * EdgeN...EdgeW
   - The BoardId of whichever board is linked in a given direction.
   - A value of 0 means no board is linked.
 * PlayerX, PlayerY
   - The player's current X and Y position on the board.
 * MouseX, MouseY
   - The position of the tile the mouse cursor is currently over.
 * ThisX, ThisY
   - the X and Y positions of the object itself.
 * BoardId
   - The Board Id of the current board.
 * Arg
   - In functions, the value passed into the function using #RUNWITH. Outside of functions, undefined.
 * Random <low> <high>
   - A random value between <low> and <high>.
 * True
   - Always 1.
 * False
   - Always 0.
 * PGet <dir> <attribute>
   - Pulls attribute data from a given tile.
   - The following attributes can be pulled from all tiles: color, fg, bg, char, walkable, pushable, canshoot, canput, seedark.
   - The following attributes can be pulled only from tiles with stats: StepX, StepY, P1, P2, P3, Cycle.
   - The following attributes can be pulled only from objects: Array, Obj1...Obj6, Locked
   - The attribute "Destination" can be pulled only from Passage.
   - The attribute INTELLIGENCE can be pulled from enemies: Shark, Bear, Lion, Ruffian, Tiger, Spinning Gun, Head.
   - The attribute SPEED can be pulled only from Slime.
   - The attribute DURATION can be pulled from Duplicators, Bombs, and Blinkwalls.
   - The attribute RATE can be pulled from Duplicator, Tiger, Blinkwall, Spinning Gun, Ruffian, and Head.

== Internal Counters: Elements ==

The extended element table contains standard information about the blocks that make up ZZT, as well as some information about the way the game is displayed and how the player behaves. 
Weave looks to the element table rather than hardcoded values for many of the behaviors that make up ZZT's core functionality. As such, it can be helpful to know which of these can be modified. All of these can be changed in-game, or set in the .CFG file.

Below is a list of the elements in the element table, and any attributes they use. Unless otherwise indicated in the description, all attributes may be modified for all elements; those not listed in the description will have little or no effect on gameplay if changed.

 * Element 0: Empty
    - Modifying Empty's attributes have complicated and often unexpected consequences. I've never done it, so if you do it and find out what happens, drop me a line and let me know.

 * Element 1: Edge
    - With #board available, there is no reason to ever use these.
    - To disable the functionality of board edges, use "#set edge.pushable false". This functionality cannot be restored. This can be useful if you want to use board links to define flow logic for a game without traditional walking mechanics.

 * Element 2: Darkness
    - Attributes used: fg, bg, char
    - Modifies the character used to represent darkness in-game.

 * Element 3: Monitor
    - Attributes used: fg, bg, char, cycle
    - "Monitor" is the element used to capture user input on the title screen. It is placed on the player's location, but is only visible when placed in-game.
    - Set Cycle to -1 to allow "#PUT <dir> [color] MONITOR" to put statless monitors by default.

 * Element 4: Player
    - Attributes used: fg, bg, char
    - Can also be modified with the #PLAYER command, or with #CHANGE PLAYER <type>.
    - Modify "playerhurt.msg" to change the message displayed when the player is damaged by a projectile or creature.
    - Modify "playerhurt.snd" to change the sound effect when the player is damaged by a projectile or creature.
    - Change "other.ouchdamage" to change the amount of health taken from the player when damaged. Default is 10.
    - Modify "gameover.msg" to change the message displayed when the player dies (health reaches 0)
    - Modify "gameover.snd" to change the sound effect when the player dies.
    - Modify "other.graceperiod" to change the # of ticks a player's health can be 0 before the player dies. Default is 0.

 * Element 5: Ammo
    - Attributes used: fg, bg, char, P1, P3
    - The P1 value is how much ammo is collected per pickup. Default is 5.
    - The P3 value is the element# that ammo turns into on collection. Default is 0 (Empty).
    - Modify "ammo.msg.touch" to change the message displayed when ammo is collected.
    - Modify "ammo.snd.touch" to change the sound played when ammo is collected.
    - Modify "cantshoot.msg" to change the message displayed when the player attempts to shoot on a board where shooting is not permitted.
    - Modify "outofammo.msg" to change the message displayed when the player attempts to shoot, but has no ammo remaining.

 * Element 6: Torch
    - Attributes used: fg, bg, char, P1, P2, P3, seedark
    - P1 represents how many torches are collected per pickup. Default is 1.
    - P2 represents how many ticks a torch provides light before extinguishing. Default is 200.
    - The P3 value is the element# that torches turn into on collection. Default is 0 (Empty).
    - Seedark is set to TRUE for torches by default.
    - Modify "torch.msg.touch" to change the message displayed when a torch is collected.
    - Modify "torch.snd.touch" to change the sound played when a torch is collected.
    - Modify "torch.snd.end" to change the sound played when a torch is extinguished.
    - Modify "darkboard.msg" to change the message displayed when the player enters a dark room for the first time.
    - Modify "notdark.msg" to change the message displayed when the player attempts to light a torch in an already lit room.
    - Modify "outoftorches.msg" to change the message displayed when the player attempts to light a torch but has no torches.
    - Increase or decrease "other.torchsize" to grow or shrink the visible range of torchlight. Default is 50.
   - Use "other.torchratioX" and "other.torchratioY" to change the shape of torchlight. Default is 1:2.

 * Element 7: Gem
    - Attributes used: fg, bg, char, P1, P2, P3, scorevalue
    - P1 is the number of gems collected on pickup. Default is 1.
    - P2 is the amount of health granted per pickup. Default is 1.
    - The P3 value is the element# that gems turn into on collection. Default is 0 (Empty).
    - ScoreValue is the number of points scored per gem pickup. Default is 10.
    - Modify "gem.msg.touch" to change the message displayed when a gem is collected.
    - Modify "gem.snd.touch" to change the sound played when a gem is collected.

 * Element 8: Key
    - Attributes used: fg, bg, char, P1, P2, P3
    - P1 is the maximum number of keys of each color a player may carry. The highest value is 99, default is 1.
    - Keys whose foreground color is dark gray or black give 256 gems, as in vanilla ZZT. The display message is no longer bugged.
    - To help distinguish keys from one another by something other than color, the P2 value is an "offset" that modifies which character represents the key.
    - The P3 value is the element# that keys turn into on collection. Default is 0 (Empty).
    - Modify "key.msg.touch1" and "key.msg.touch2" to change the message displayed when collecting a key.
    - Modify "key.snd.touch" to change the sound played when a key is collected.
    - Modify "key.msg.fail1" and "key.msg.fail2" to change the message displayed when attempting to collect a key when you already carry the maximum number of that color key.
    - Modify "key.snd.fail" to change the sound played when attempting to collect a key that cannot be collected.

 * Element 9: Door
    - Attributes used: fg, bg, char, P3
    - The P3 value is the element# that doors turn into when opened. Default is 0 (Empty).
    - Modify "door.msg.touch1" and "door.msg.touch2" to change the message displayed when opening a door.
    - Modify "door.snd.touch" to change the sound played when a door is opened.
    - Modify "door.msg.fail1" and "door.msg.fail2" to change the message displayed when attempting to open a door while not having the key.
    - Modify "door.snd.fail" to change the sound played when failing to open a door.

 * Element 10: Scroll
    - Attributes used: char
    - Modify "scroll.snd" to change the sound effect when a scroll is touched.
    - Modify "default.scroll.name" to change the text displayed at the top of a scroll not otherwise named with @Name.

 * Element 11: Passage
    - Attributes used: char, cycle, P3
    - Modify "passage.snd" to alter the sound played when a passage is entered.
    - P3 is the boardId of a passage's default destination.
    - To always #PUT passages that are statless (they will all go to the boardId set in P3) set the cycle to -1.

 * Element 12: Duplicator
    - Attributes used: none
    - Modify "duplicator.snd" and "dupeblocked.snd" to change the sound effects associated with duplicators.

 * Element 13: Bomb
    - Attributes used: fg, bg, char, cycle, P1, P3
    - P1 is the position in the countdown a bomb is in when placed with #PUT BOMB. Default is 0 (unlit)
    - P3 is the number of bomb ticks the game adds to each step in the countdown. Default is 0.   
    - Modify "bomb.msg.touch" to change the message displayed when activating a bomb.
    - Modify "bomb.snd.touch" to change the sound played when activating a bomb.
    - Modify "bomb.snd.tick" and "bomb.snd.tock" to change the sound effects played while the bomb ticking down.
    - Modify "bomb.snd.explode" to change the explosion sound effect.
    - Increase or decrease "other.bombsize" to grow or shrink the size of bomb explosions. Default is 50.
   - Use "other.bombratioX" and "other.bombratioY" to change the shape of explosions. Default is 1:2.

 * Element 14: Energizer
    - Attributes used: fg, bg, char, P1, P3
    - P1 is the number of ticks of ENERGIZED given the player when collected. Default is 75.
    - Modify "energizer.msg.touch" to change the message displayed when an Energizer is collected.
    - Use "energizer.snd.song1", "energizer.snd.song2", "energizer.snd.song3", "energizer.snd.song4", and "energizer.snd.end" to build the energizer song.
    - The P3 value is the element# that energizers turn into when collected. Default is 0 (Empty).

 * Element 15: Star
    - Attributes used: Cycle, P1, P2
    - P1 identifies whether stars have a limited lifespan. Default is True.
    - P2 identifies the length of that lifespan in star ticks. Default is 100.

 * Element 16: Clockwise
    - Attributes used: None

 * Element 17: Counter
    - Attributes used: None

 * Element 18: Bullet
    - Attributes used: fg, bg, char, cycle, P1, P2, P3
    - P1 identifies whether bullets have a limited lifespan. Default is False.
    - P2 identifies the length of that lifespan in bullet ticks. Default is 50.
    - P3 identifies whether objects using #SHOOT produce creature bullets, and so can't kill creatures. Default is True. If set to False, objects using #SHOOT produce player bullets instead.
    - Modify "playershoot.snd" and "objectshoot.snd" to change the sound effects played when a player and object shoot a bullet, respectively.
    - Modify "statdeath.snd" to change the sound played when an element with stats is destroyed by a bullet or other destructive action.
    - Set Cycle to -1 to allow "#PUT <dir> [color] BULLET" to put statless monitors by default.

 * Element 19: Water
    - Attributes used: char, canput, seedark
    - Modify "water.msg.touch" and "water.snd.touch" to change the message and sound effect associated with clearing forest.

 * Element 20: Forest
    - Attributes used: fg, bg, char, P3
    - The P3 value is the element# that forests turn into when cleared. Default is 0 (Empty).
    - Modify "forest.msg.touch" and "forest.snd.touch" to change the message and sound effect associated with clearing forest.

 * Element 21: SOLID
    - Attributes used: char, walkable, pushable, canshoot, canput, seedark

 * Element 22: NORMAL
    - Attributes used: char, walkable, pushable, canshoot, canput, seedark

 * Element 23: BREAKABLE
    - Attributes used: char, walkable, pushable, canshoot, canput, seedark
    - Modify "breakable.snd" to change the sound effect when a non-statted element, like a breakable, is destroyed with a bullet.

 * Element 24: BOULDER
    - Attributes used: char, walkable, pushable, canshoot, canput, seedark
    - Modify "push.snd" to change the sound effect when a boulder, slider, or other pushable element is pushed by the player, or when a pusher moves.

 * Element 25: SLIDERNS
    - Attributes used: char, walkable, canshoot, canput, seedark

 * Element 26: SLIDEREW
    - Attributes used: char, walkable, canshoot, canput, seedark

 * Element 27: FAKE
    - Attributes used: char, walkable, pushable, canshoot, canput, seedark
    - Modify "fake.msg.touch" to change the message displayed when a player first steps onto a fake.

 * Element 28: INVISIBLE
    - Attributes used: char, canshoot, seedark, P1
    - P1 is the element # an invisible turns into when touched. Default is 22 (Normal)
    - Modify "invisible.msg.touch" and "invisible.snd.touch" to change the message and sound effect associated with touching an invisible wall.

 * Element 29: BLINKWALL
    - Attributes used: char, cycle
    - Set Cycle to -1 to allow "#PUT <dir> [color] BLINKWALL" to put statless blinkwalls by default.

 * Element 30: TRANSPORTER
    - Attributes used: None
    - Modify "transporter.snd" to change the sound made when something is sent through a transporter.

 * Element 31: LINE
    - Attributes used: walkable, pushable, canshoot, canput, seedark
    - To redraw in-game, #CHANGE LINE LINE has always been preferred but I think also #clear isdark might work? I dunno I wanna play more with these

 * Element 32: RICOCHET
    - Attributes used: fg, bg, char, walkable, pushable, canput, seedark
    - Modify "ricochet.snd" to change the sound effect of a bullet bouncing off a ricochet.

 * Element 33: BLINKEW
    - Attributes used: char, walkable, pushable, canshoot, canput, seedark

 * Element 34: BEAR
    - Attributes used: fg, bg, char, cycle, P1, scorevalue
    - Modify P1 to set default Sensitivity 0-8 (0 = wide, 8 = narrow)
    - Set Cycle to -1 to allow "#PUT <dir> [color] BEAR" to put statless bears by default.

 * Element 35: RUFFIAN
    - Attributes used: fg, bg, char, cycle, P1, P2, scorevalue
    - Modify P1 to set default Intelligence 0-8 (0 = random, 8 = seek)
    - Modify P2 to set default Resting Rate 0-8 (0 = short, 8 = long))
    - Set Cycle to -1 to allow "#PUT <dir> [color] RUFFIAN" to put statless ruffians by default.

 * Element 36: OBJECT
    - Attributes used: bg
    - Use "#SET object.bg True" to have objects carry their background with them when they move. Use #SET object.bg False" to restore the vanilla ZZT behavior (objects adopt the background of the tile they're on).
    - Modify "default.object.name" to change the text displayed at the top of a text box generated by an un-@Name'd object.
    - Modify "error.msg" and "error.snd" to change the message and sound when an object encounters a ZZT-OOP error. "#CLEAR error.msg" will cause errors to be ignored.
    - Set "other.friendlyfire" to False to disable object-to-object friendly fire (Object bullets no longer invoke the :SHOT label). Default is True.
    - Increase "other.maxoop" to raise the limit on lines of ZZT-OOP an object can execute per tick. Default is 33.

 * Element 37: SLIME, p2
    - Attributes used: fg, bg, char
    - Modify P2 to set default Speed 0-8 (0 = fast, 8 = slow)

 * Element 38: SHARK
    - Attributes used: fg, bg, char, P1, canshoot, cycle
    - Modify P1 to set default Intelligence 0-8 (0 = random, 8 = seek)
    - Set CanShoot to True to damage sharks with bullets, as with other creatures.
    - Set Cycle to -1 to allow "#PUT <dir> [color] SHARK" to put statless sharks by default.

 * Element 39: SPINNINGGUN
    - Attributes used: P1, P2, cycle
    - Modify P1 to set default Intelligence 0-8 (0 = random, 8 = seek)
    - Modify P2 to set default Firing Rate: 0-8 to shoot BULLETs (0 = few, 8 = many) or 128-136 to throw STARs (128 = few, 136 = many)
    - Set Cycle to -1 to allow "#PUT <dir> [color] SPINNINGGUN" to put statless spinning guns (arrows point randomly when redrawn) by default. This allows for "#CHANGE SPINNINGGUN SPINNINGUN" which will make them rotate without stats.

 * Element 40: PUSHER
    - Attributes used: fg, bg, char, cycle
    - Set Cycle to -1 to allow "#PUT <dir> [color] PUSHER" to put statless pushers by default.

 * Element 41: LION
    - Attributes used: fg, bg, char, cycle, P1, scorevalue
    - Modify P1 to set default Intelligence 0-8 (0 = random, 8 = seek)
    - Set Cycle to -1 to allow "#PUT <dir> [color] LION" to put statless lions by default.

 * Element 42: TIGER
    - Attributes used: fg, bg, char, cycle, P1, P2, scorevalue
    - Modify P1 to set default Intelligence 0-8 (0 = random, 8 = seek)
    - Modify P2 to set default Firing Rate: 0-8 to shoot BULLETs (0 = few, 8 = many) or 128-136 to throw STARs (128 = few, 136 = many)
    - Set Cycle to -1 to allow "#PUT <dir> [color] TIGER" to put statless tigers by default.

 * Element 43: BLINKNS
    - Attributes used: char, walkable, pushable, canshoot, canput, seedark
 
 * Element 44: HEAD
    - Attributes used: fg, bg, char, cycle, P1, P2, scorevalue
    - Modify P1 to set default Intelligence 0-8 (0 = random, 8 = seek)
    - Modify P2 to set default Deviance Rate 0-8 (0 = straight, 8 = deviant)
    - Set Cycle to -1 to allow "#PUT <dir> [color] HEAD" to put statless heads by default.

 * Element 45: SEGMENT
    - Attributes used: fg, bg, char, cycle, P1, P2, scorevalue
    - Modify P1 to set default Intelligence 0-8 (0 = random, 8 = seek)
    - Modify P2 to set default Deviance Rate 0-8 (0 = straight, 8 = deviant)
    - Set Cycle to -1 to allow "#PUT <dir> [color] SEGMENT" to put statless segments by default.

 * Element 46: CUSTOMTEXT
    - Attributes used: fg, bg, walkable, pushable, canshoot, canput, seedark
    - The "fg" and "bg" attributes are only used by the element called "CUSTOMTEXT", which is the base custom text (default is dark gray on black).
    - The walkable, pushable, canshoot, canput, and seedark properties are inherited by all text created with #WRITE, as well as all custom text placed in Loom/ZLoom2.

 * Element 47: BLUETEXT
    - Attributes used: fg, bg, walkable, pushable, canshoot, canput, seedark

 * Element 48: GREENTEXT
    - Attributes used: fg, bg, walkable, pushable, canshoot, canput, seedark

 * Element 49: CYANTEXT
    - Attributes used: fg, bg, walkable, pushable, canshoot, canput, seedark

 * Element 50: REDTEXT
    - Attributes used: fg, bg, walkable, pushable, canshoot, canput, seedark

 * Element 51: PURPLETEXT
    - Attributes used: fg, bg, walkable, pushable, canshoot, canput, seedark

 * Element 52: YELLOWTEXT
    - Attributes used: fg, bg, walkable, pushable, canshoot, canput, seedark

 * Element 53: WHITETEXT
    - Attributes used: fg, bg, walkable, pushable, canshoot, canput, seedark


== Internal Counters: Other ==

There are some internal counters labeled "other" that don't otherwise fall into the above categories. They are:

 * other.startboard
   - Sets the boardId of the start board.
   - Default is -1 (reads from the .ZZT file instead)

 * other.footsteps
   - Retains or eliminates ZZT's footstep sound.
   - Default is False (its loudness varies too much across setups)

 * other.highscores
   - Sets the # of high scores to save (Default is 30, Maximum is 30)
   - Set to False to eliminate the use of high scores entirely.

 * other.strictwindow
   - Restricts the closing of text windows to ENTER, as in vanilla ZZT, as opposed to allowing both ENTER and SPACE, as in previous versions of Weave.
   - Defaults to False.

== Internal Counters: Theme ==

One final category relates to all of the colors that make up ZZT's UI elements:

 * "theme.bg.sidebar" is the color of the sidebar and dividing line.
    - Defaults to 1 (DkBlue with no dividing line)
    - Available values of 0-271.
    - Colors 0-15 are sidebars with no dividing line.
    - Colors 16-31 are sidebars with DkBlue dividing line.
    - Colors 32-47 are sidebars with DkGreen dividing line.
    - Colors 48-63 are sidebars with DkCyan dividing line.
    - Colors 64-79 are sidebars with DkRed dividing line.
    - Colors 80-95 are sidebars with DkPurple dividing line.
    - Colors 96-111 are sidebars with Brown dividing line.
    - Colors 112-127 are sidebars with Gray dividing line.
    - Colors 128-143 are sidebars with DkGray dividing line.
    - Colors 144-159 are sidebars with Blue dividing line.
    - Colors 160-175 are sidebars with Green dividing line.
    - Colors 176-191 are sidebars with Cyan dividing line.
    - Colors 192-207 are sidebars with Red dividing line.
    - Colors 208-223 are sidebars with Purple dividing line.
    - Colors 224-239 are sidebars with Yellow dividing line.
    - Colors 240-255 are sidebars with White dividing line.
    - Colors 256-271 are sidebars with Black dividing line.
 * theme.fg.text1
    - This is the primary color for text in the UI, as well as the color of text in scrolls preceded by $.
    - Default is "White".    
 * theme.fg.text2
    - This is the color of counters tracked in the sidebar, as well as the primary color of text in scrolls.
    - Default is "Yellow".
 * theme.fg.alt
    - This is the color of text used in the sidebar to label hotkeys.
    - Default is "Black".
 * theme.bg.alt1
    - This is the backgound color of hotkey labels in the sidebar, alternating lines with "theme.bg.alt2".
    - Default is "Gray".
 * theme.bg.alt2
    - This is the backgound color of hotkey labels in the sidebar, alternating lines with "theme.bg.alt1".
    - Default is "DkCyan".
 * theme.fg.special
    - This is the color of the "gem" in the sidebar as well as the "special text" designated above in Part 2: Line Formatting.
 * theme.blinking
    - This toggles the game's display between Blinking Colors (128-255 blink) and High-Intensity Backgrounds (128-255 don't blink and have bright backgrounds)
    - Defaults to True, whith colors 128-255 as blinking colors.

 * pal.<color>
    - Default palette values can be defined in the .CFG file.
    - These entries are overruled by a provided .PAL file.
    - #PALETTE commands in-game change these values, though when the player quits or opens the prompt to quit, it returns to the defaults defined here.
    - The format matches the following: "pal.black = [ 0, 0, 0 ]"
    - The 0, 0, 0 are the r, g, and b values for the indicated color.
    - The range for r, g, and b is 0-63, matching the range for #PALETTE.
    - See also the #PALETTE command.

== Disabling Messages and Sounds ==

Messages (attributes containing ".msg") and Sounds (attributes containing ".snd") can be silenced using #clear. For example:

    #CLEAR water.msg.touch

This will remove the text displayed when a player touches water. To remove the corresponding sound, use:

    #CLEAR water.snd.touch

To put something in its place, use #SET. For example:

    #SET water.msg.touch You don't know how to swim!

Now, when the player first touches water, this will be the message displayed.


#####################
     Appendix A
    Destinations
#####################

Board destinations can take a few different forms, and are used in a few ways. Commands such as #BOARD and #EDGE use them, and passages can be modified to new destinations with #PSET. The different forms these destinations can take are listed below:

 * A board :label

If a board name includes a label, such as ":somelabel;My Board", then it can be referenced in #BOARD and other commands with a destination. In this example:

    #BOARD somelabel 10 5

Will transport the player to a board labeled :somelabel and attempt to put the player at location (10, 5) on that board.

 * A board edge
    - EdgeN, EdgeS, EdgeE, or EdgeW

If a board has a valid board connection, this can be referenced in #BOARD and other commands with a destination. "#BOARD EdgeW" will attempt to send the player directly to the board linked to the west. Note, it is wise to validate that such a link exists, using "#IF EdgeW BOARD EdgeW" or similar; otherwise the player may end up on the title screen.

 * A stored BoardID
    - A BoardID stored in a custom counter, such as 'ReturnTo'

If a custom counter has been defined in the game's INI file, for example:

    world.counter = "ReturnTo"

This can store a BoardId value for later use. Say you wanted to visit a board, like a map or menu, and then return to wherever you came from. You could accomplish this by running the following commands:

    #SET ReturnTo BoardId
    #BOARD MapScreen

This would save the current board in the 'ReturnTo' counter and teleport the player to a board named ":MapScreen;Overworld Map" or similar. Once you were done, you could send the player back with:

    #BOARD ReturnTo

This would return the player to their previous board.

####################
    Appendix B:
     Functions
####################

There are several ways to execute a function in Weave. They include:

 * Basic Evaluation
    #RUN <function>
    #RUNWITH <counter> <function>
 * Conditional Evaluation
    #IF RUN <function>
    #IF RUNWITH <counter> <function>
 * Substitution Evaluation
    #GIVE/TAKE/SET <counter> RUN <function>
    #GIVE/TAKE/SET <counter> RUNWITH <counter> <function>

See the section marked "SUBSTITUTION" in Part Seven of this document, and the "Returning Substitutions" section of this appendix, for more on substitution evaluation.

A function can take two forms:
 * A .OBJ file
    - For example, "#RUN lemon" would execute code out of the LEMON.OBJ file in the same directory as your ZZT game file.
 * A :label
    - For example, "#RUN :lemon" will look for a label :lemon in this object's code and execute it as a function.

== Differences to normal code ==

 * Functions always run for a single cycle only.
    - If they hit #END or any other cycle-stopping command such as #SHOOT, #IDLE or #GO, they will stop executing immediately and return to where they were previously in the code.
 * Functions run forever until stopped.
    - If you create an infinite loop, the game will freeze.
 * Functions should not destroy stats.
    - Functions can create stats, but should not destroy them; be careful with how you use #put.
    - This includes itself. Do not use #die or #become within a function.
 * Functions CANNOT be nested.
    - Do NOT call a function from another function, or invoke a function from itself.
    - :loops can be used, but make sure they are guaranteed to terminate.
 * Functions using RUNWITH pass an additional value as an argument for that function.
    - This becomes available inside the function as a readonly counter: ARG.
    - Inside the function, ARG can replace any numeric value.
    - The value of ARG cannot be altered with #SET, #GIVE or #TAKE
    - Outside of a function, the ARG value is undefined.

== Returning Conditionals ==

If you are using a function as a conditional (WITH #IF), the following will cause a function to terminate and evaluate True:

 * #END TRUE
 * #END <#>
    - As long as <#> is a positive number.
 * #END <counter>
    - As long as <counter> is a positive value.

The following will evaluate False:

 * #END
 * #END FALSE
 * any /movement or other commands that break the cycle
 * #END <#>
    - As long as <#> is 0 or negative.
 * #END <counter>
    - As long as <counter> is not a positive value.

== Returning Substitutions ==

If you are using RUN <function> or RUNWITH <counter> <function> in place of a number in another command such as #TAKE or #SET, keep in mind the following:

 * #END <#>
    - This will return <#> to the command.
    - Keep in mind <#> cannot be substituted for another function, as functions cannot be nested.
 * #END <counter>
    - This will return the value of <counter> to the command.
 * #END
    - This will return -1.
    - Any /movement or #commands that break cycle will return -1 as well.

#############################
         Appendix C:
     Color Substitution
#############################

All colors in Weave can be represented with a number:

    0: Black
    1: DkBlue
    2: DkGreen
    3: DkCyan
    4: DkRed
    5: DkPurple
    6: Brown
    7: Gray
    8: DkGray
    9: Blue
    10: Green
    11: Cyan
    12: Red
    13: Purple
    14: Yellow
    15: White

As such, these values can be stored in counters, and used in-game in place of a color wherever a color can be found in the code. While numbers 0 through 15 are sufficient to store a single foreground or background color, a counter can also store both at once:

    0-15: Black background
    16-31: DkBlue background
    32-47: DkGreen background
    48-63: DkCyan background
    64-79: DkRed background
    80-95: DkPurple background
    96-111: Brown background
    112-127: Gray background
(Note: Colors higher than 127 blink, if theme.blinking is set to true, or display as bright backgrounds, if theme.blinking is set to false.)
    128-143: DkGray background (Or Black blinking, if theme.blinking is set to True)
    144-159: Blue background (Or DkBlue + blinking)
    160-175: Green background (Or DkGreen + blinking)
    176-191: Cyan background (Or DkCyan + blinking)
    192-207: Red background (Or DkRed + blinking)
    208-223: Purple background (Or DkPurple + blinking)
    224-239: Yellow background (Or Brown + blinking)
    240-255: White background (Or Gray + blinking)

While it is usually not recommended, you can use numbers instead of color names when writing ZZT-OOP. Consider:

    #CHANGE 9 FAKE EMPTY (this is the same as #CHANGE BLUE FAKE EMPTY)

There is one place where this IS recommended: when using text of any kind (custom and standard), the displayed character is stored in ZZT as its color. As such, it can be useful to refer to the character when working with text. For example, Char 69 is a capital E in the standard character set, so a command that changes all blue solids into blue text that reads "EEEEEEE" would be:

    #CHANGE BLUE SOLID 69 BLUETEXT

Numbers and colors are interchangable everywhere a color is referenced.


#############################
         Appendix D:
          WEAVE.CFG
#############################

The first line of Weave.CFG is always the default .ZZT file to load on running Weave. In freshly downloaded copies of Weave, this is the Demo world, WEAVEDMO. When distributing a Weave game, you will set it to the name of your .ZZT file.

The second line of WEAVE.CFG, if there is one, is 'ACCESSIBLE'. Without any other options below it, it will start Weave as normal but ask about enabling modes used by Weave to improve accessibility of legacy ZZT games.

All additional lines will be one of the following:

 * SKIPTOTITLE
    - This will skip all preamble and display the title screen of your game on startup.
 * TITLEONLY
    - This disables the option to 'P'lay the game.
    - Instead, to play, a #STARTGAME command must be used by an object on the title screen.
 * SPEED <1-9>
    - This sets the TickSpeed the game will use by default.
    - 5 is normal speed, while 1 is as fast as possible.
 * RELEASE or WEBRELEASE
    - Paired with disabled saves in the game's .CFG file (keys.save.bind = ""), this disables the option to 'R'estore a game from the title screen.
    - If there is only one .ZZT file in the directory, the option to select a different 'W'orld is disabled.
    - If there is a 'SPEED' defined in WEAVE.CFG, the option to change the game's 'S'peed on the title screen is disabled.
    - In addition to the above, WEBRELEASE disables the option to 'Q'uit from the title screen, as for a web-playable Weave game, you simply navigate away from the page.
 * NEUROMOTORASSIST, VISUALSOUND, KEYSHAPES - these force the different accessibility modes used by Weave to improve the accessibility of legacy ZZT games.